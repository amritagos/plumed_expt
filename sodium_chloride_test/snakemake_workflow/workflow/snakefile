import numpy as np
import pandas as pd
from pathlib import Path
import json

NUMBER_OF_WINDOWS = 25
DISTANCE_LOWEST = 2.0
DISTANCE_HIGHEST = 6.0
BOX_DIMENSION = 12.35 # For a box of given size 
NUM_WATER_MOLECULES = 64
NUM_CATIONS = 1
NUM_ANIONS = 1
LAMMPS_TYPE_NUMBER_CATION = 3
LAMMPS_TYPE_NUMBER_ANION = 4
LAMMPS_TYPE_NUMBER_O = 1
LAMMPS_TYPE_NUMBER_H = 2
ASE_TYPE_CATION = 11 # Na 
ASE_TYPE_ANION = 17 # Cl
ASE_TYPE_O = 8 # O 
ASE_TYPE_H = 1 # H 
INTERACTION_CUTOFF = 6.0 # Should be less than or equal to half the box length 
NUM_STEPS_MD = 200 # Number of steps for the MD per window, was 200000 in tutorial

distances = np.linspace(DISTANCE_LOWEST, DISTANCE_HIGHEST, NUMBER_OF_WINDOWS)
input_dict = {str(i): value for i, value in enumerate(distances)}

SAMPLES = list(input_dict.keys())

rule all:
    input: 
        expand("results/window_inputs/{sample}/system.xyz", sample=SAMPLES),
        expand("results/sampling_1/{sample}/out.traj", sample=SAMPLES)

rule packmol_input:
    input:
        cation = "resources/packmol/na.xyz",
        anion = "resources/packmol/cl.xyz",
        water = "resources/packmol/tip4p_2005_water.xyz",
    params:
        system = "results/packmol/{sample}/system.xyz",
        distance = lambda wc: input_dict[wc.sample],
        n_waters = NUM_WATER_MOLECULES,
        box_length = BOX_DIMENSION,
    output:
        packmol = "results/packmol/{sample}/packmol.inp"
    shell:
        "python workflow/scripts/gen_packmol_input.py --cation_file {input.cation} --anion_file {input.anion} --water_file {input.water} --system_file {params.system} --ion_distance {params.distance} --n_wat {params.n_waters} --output_path {output.packmol} --box_dims {params.box_length} {params.box_length} {params.box_length}"

rule run_packmol:
    input:
        packmol = rules.packmol_input.output.packmol
    output:
        packmol = "results/packmol/{sample}/system.xyz"
    shell:
        "packmol < {input.packmol}"

rule moltemplate_input:
    input:
        cation = "resources/moltemplate/fe.lt",
        anion = "resources/moltemplate/cl.lt",
        water = "resources/moltemplate/tip4p_2005.lt",
    params:
        n_cations = NUM_CATIONS,
        n_anions = NUM_ANIONS,
        n_waters = NUM_WATER_MOLECULES,
        box_length = BOX_DIMENSION,
    output:
        moltemplate = "results/moltemplate/{sample}/system.lt"
    shell:
        "python workflow/scripts/gen_moltemplate_input.py --cation_file {input.cation} --anion_file {input.anion} --water_file {input.water} --n_cations {params.n_cations} --n_anions {params.n_anions} --n_wat {params.n_waters} --box_dims {params.box_length} {params.box_length} {params.box_length} --output_path {output.moltemplate}"

rule run_moltemplate: 
    input: 
        system = rules.moltemplate_input.output.moltemplate,
        xyz = rules.run_packmol.output.packmol
    params:
        moltemplate_dir = "results/moltemplate/{sample}",
        full_system_lt_path = str(Path(rules.moltemplate_input.output.moltemplate).resolve()),
        full_xyz_path = str(Path(rules.run_packmol.output.packmol).resolve())
    output: 
        data = Path("results/moltemplate/{sample}/system.data")
    shell:
        "cd {params.moltemplate_dir} && moltemplate.sh -atomstyle \"full\" {params.full_system_lt_path} -xyz {params.full_xyz_path} && rm -rf output_ttree system.in.init system.in.settings run* && cd ../../../"

rule lammps_data_to_xyz:
    input: 
        data = rules.run_moltemplate.output.data
    params: 
        cation_type_initial = LAMMPS_TYPE_NUMBER_CATION,
        cation_type_final = ASE_TYPE_CATION,
        anion_type_initial = LAMMPS_TYPE_NUMBER_ANION,
        anion_type_final = ASE_TYPE_ANION,
        o_type_initial = LAMMPS_TYPE_NUMBER_O,
        o_type_final = ASE_TYPE_O,
        h_type_initial = LAMMPS_TYPE_NUMBER_H,
        h_type_final =  ASE_TYPE_H,
    output: 
        xyz = "results/window_inputs/{sample}/system.xyz"
    shell:
        "python workflow/scripts/convert_data_to_xyz.py --data_file {input.data} --cation_type_data {params.cation_type_initial} --cation_type_ase {params.cation_type_final} --anion_type_data {params.anion_type_initial} --anion_type_ase {params.anion_type_final} --o_type_data {params.o_type_initial} --o_type_ase {params.o_type_final} --h_type_data {params.h_type_initial} --h_type_ase {params.h_type_final} --output_xyz {output.xyz}"

rule umbrella_sampling_1: 
    input:
        xyz = rules.lammps_data_to_xyz.output.xyz
    params:
        cutoff = INTERACTION_CUTOFF,
        distance = lambda wc: input_dict[wc.sample],
        n_steps = NUM_STEPS_MD,
        colvar = Path("results/sampling_1/{sample}/COLVAR_{sample}").resolve(), # Full path likely needed for PLUMED
    output:
        colvar = "results/sampling_1/{sample}/COLVAR_{sample}",
        traj = "results/sampling_1/{sample}/out.traj",
        metadata = "results/sampling_1/{sample}/metadata.json"
    shell:
        "python workflow/scripts/umbrella_sampling_1.py --in_xyz_file {input.xyz} --max_cutoff {params.cutoff} --ion_distance {params.distance} --n_steps {params.n_steps} --colvar_file {output.colvar} --traj_file {output.traj} --metadata_file {output.metadata}"